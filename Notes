management.endpoints.web.exposure.include=*
//if you by mistakenly give more space "= *" it might throw error as Caused by: java.lang.IllegalArgumentException: 'value' must only contain valid chars


#Actuators:
Spring Boot Actuator is a built‑in module that gives you production‑ready monitoring and management tools for your application.
In short:
It exposes endpoints (like /actuator/health, /actuator/info, /actuator/metrics) that let you check the app’s health, environment, and performance.
It helps with observability: you can see memory usage, request counts, database connectivity, and more.
It supports integration with monitoring tools (Prometheus, Micrometer, etc.), so you can collect metrics automatically.
You control which endpoints are visible using properties like:
management.endpoints.web.exposure.include=health,info,metrics(exposes specific, if all ue *)

#Git Specfic info in Actuator
The git-commit-id-maven-plugin is configured to generate a git.properties file during the build. This file contains selected Git metadata (branch, commit ID, author, commit message, etc.), which Spring Boot Actuator automatically exposes through the /actuator/info endpoint.
With this setup, whenever the application is built, the current Git information is embedded into the JAR and can be retrieved at runtime via Actuator.
It always records the commit that was checked out when you ran the build (e.g., mvn package or mvn install).
	<plugin>
				<groupId>io.github.git-commit-id</groupId>
				<artifactId>git-commit-id-maven-plugin</artifactId>
				<executions><execution><goals<goal>revision</goal></goals></execution></executions>
				<configuration>
					<failOnNoGitDirectory>false</failOnNoGitDirectory>
					<failOnUnableToExtractRepoInfo>false</failOnUnableToExtractRepoInfo>
					<generateGitPropertiesFile>true</generateGitPropertiesFile>
					<includeOnlyProperties>
						<includeOnlyProperty>^git.branch$</includeOnlyProperty>
						<includeOnlyProperty>^git.commit.id.abbrev$</includeOnlyProperty>
						<includeOnlyProperty>^git.commit.user.name$</includeOnlyProperty>
						<includeOnlyProperty>^git.commit.message.full$</includeOnlyProperty>
					</includeOnlyProperties>
				</configuration>
			</plugin>

{
  "git": {
    "branch": "master",
    "commit": {
      "id": "cf907ae",
      "time": "2026-02-19T14:31:52Z"
    }
  },
  "build": {
    "artifact": "catalog-service",
    "name": "catalog-service",
    "time": "2026-02-19T14:46:40.872Z",
    "version": "0.0.1-SNAPSHOT",
    "group": "com.priyanka"
  }
}


#Swagger-Open Api
The project uses Springdoc OpenAPI Starter WebMVC UI (version 2.5.0) to integrate Swagger/OpenAPI with Spring Boot 3.x. This dependency automatically generates OpenAPI 3 specifications for all REST controllers and exposes them through an interactive Swagger UI. Developers can access the UI at (http://localhost:8081/swagger-ui/index.html) to explore and test endpoints without additional configuration. By using the starter, the application remains compatible with Spring Boot 3.x and Jakarta EE, avoiding issues caused by older Springdoc versions.
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.5.0</version>
		</dependency>

#Java code formatting Dependency
The Spotless Maven plugin is configured to automatically enforce consistent Java code style during the build process. It removes unused imports, applies Palantir’s Java formatter, and ensures annotations and import order are standardized. By binding the plugin to the compile phase, every build guarantees clean, well‑formatted code. Developers can also run spotless:apply to reformat code or spotless:check to validate formatting, making Spotless a powerful tool for maintaining code quality and consistency across the team.
    <plugins>
        <plugin>
            <groupId>com.diffplug.spotless</groupId>
            <artifactId>spotless-maven-plugin</artifactId>
            <version>2.45.0</version>
            <configuration>
                <java>
                    <importOrder />
                    <removeUnusedImports />
                    <palantirJavaFormat>
                        <version>2.35.0</version>
                    </palantirJavaFormat>
                    <formatAnnotations />
                </java>
            </configuration>
            <executions>
                <execution>
                    <phase>compile</phase>
                    <goals>
                        <goal>apply</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>

  #Flyway Migration Dependency
  <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-core</artifactId>
  </dependency>

Manages Schema Versions : Flyway tracks the state of your database schema using a versioning system. Each migration script (SQL or Java) is assigned a version number, and Flyway ensures they run in the correct order.
Applies Migrations Automatically:  On application startup (e.g., in Spring Boot), Flyway scans for migration files in your project (usually under db/migration) and applies any that haven’t been executed yet.
Ensures Consistency:  Prevents the same script from being executed multiple times. It records applied migrations in a special metadata table (flyway_schema_history).
--> What it does
Flyway is like Git for your database.
It keeps track of changes (migrations) to your database schema (tables, columns, etc.).
Each change is stored in a file with a version number (e.g., V1__create_table.sql, V2__add_data.sql).
-->How It Works
You put migration files in src/main/resources/db/migration.
When your app starts, Flyway looks at those files.
It checks a special table (flyway_schema_history) in your database to see which migrations have already been applied.
If new ones exist, Flyway runs them in order and records them in the history table.
-->Key Points
File names must follow the convention:
V<number>__description.sql (e.g., V1__create_products_table.sql).
Wrongly named files are ignored silently.
Once applied, migrations are tracked in flyway_schema_history
**with Flyway, if you already inserted 20 rows into a table using one migration file and later want to add 10 more rows, you don’t edit the old file. Instead, you create a new migration file with the next version number (like V2__add_more_rows.sql). Flyway tracks migrations by file name and version, and once a migration is applied it’s recorded in the flyway_schema_history table. If you change an old file, Flyway won’t re-run it because it thinks it’s already applied, so the only way to apply new changes is to create a new file with a higher version number. This ensures every change is applied in order and consistently across all environments.